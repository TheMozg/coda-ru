# Тестирование компонентно-ориентированного ПО

## Введение

В предыдущих главах мы узнали о принципах КОРС, различных компонентных моделях, доступных в Java, и о том как разрабатывать и проектировать компонентно-ориентированную систему. В этой главе мы рассмотрим тестирование системных компонентов. Тестирование играет большую роль в обеспечении качества ПО. Как мы увидим дальше, тестирование системных компонентов немного отличается традиционного тестирования.

## Понятия в тестировании ПО

Как и во всех других сферах жизни, человеку свойственно ошибаться и в разработке программного обеспечения. Без надлежащего тестирования нельзя считать, что программное обеспечение является правильным, полным и качественным. После того как команда программистов закончит разработку, независимая группа тестировщиков проводит контроль качества разработанного ПО. Тестирование выявляет ошибки в реализации логики, пропущенный при реализации функционал, и другие качественные недостатки. Все это записывается как дефекты программы. После первого раунда тестирования обнаруженные дефекты устраняются и продукт подвергается следующему раунду тестирования. Контроль качества ПО может включать в себя несколько раундов тестирования, устранения ошибок и повторного тестирования, пока ошибки не будут уменьшены до приемлемого уровня.

Различные типы тестов проводятся на различных этапах традиционного жизненного цикла разработки ПО. Некоторые виды тестов проверяют соответствующие артефакты процесса разработки, а не самого продукта. Мы сосредоточимся на методах тестирования, охватывающих программу, а не артефакты.

По ходу процесса разработки, как только работа над небольшим модулем ПО закончена, разработчики проводят модульное тестирование.

Модульное тестирование подразумевает проверку разработанного ПО на основе знаний о внутренней спецификации реализации и фактической реализации программного обеспечения. Такое тестирование называется тестированием методом белого ящика.

Когда отдельные разработчики завершают программирование поставленных задач, участки программы собираются воедино и интегрируются. Проводятся тесты, чтобы убедиться, что блоки ПО работают и взаимодействуют согласно спецификации. Тестирование на этом этапе известно как интеграционное тестирование. Как правило, интеграционное тестирование использует принцип белого ящика.

Когда программное обеспечение для всей системы готово, система проверяется на соответствие техническим требованиям. Этот этап тестирования известен как системное тестирование. В отличие от двух других фаз тестов, в которых применялось тестирование белого ящика, системное тестирование принимает систему как черный ящик, без каких-либо предположений о реализации. Смысл тестов черного ящика в том, чтобы убедиться что функциональность всей системы соответствует указанной в спецификации. Тестовые случаи разрабатываются только с оглядкой на спецификацию, без знаний о требований к реализации или знаний о самой реализации. Такое тестирование называется тестированием черного ящика.

## Понятия в тестировании компонентно-ориентированного ПО

Цикл разработки компонентно-ориентированного ПО отличается от традиционного жизненного цикла разработки как уже описано в главе 1.8. В этой главе объясняется, что компоненты берутся либо уже в готовом виде, либо разрабатываются до сборки в систему. В любом случае, до сборки компоненты нужно протестировать. Тестирование компонентов можно в общем разделить на функциональное тестирование и тестирование качества сервиса.

Функциональное тестирование включает:
1. Валидацию интерфейсов компонентов
2. Верификацию реализации компонентов - тестирование белого ящика
3. Верификацию функциональности компонентов - тестирование черного ящика

Тестирование качества сервиса включает:
1. Верификацию производительности компонентов
2. Верификацию обработки ошибок компонента
3. Верификацию точности данных компонента
4. Верификацию функциональности компонента на восстановление после ошибок
5. Верификацию возможности повторного использования компонента
6. Верификацию надежности компонента
7. Оценку возможной степени поддержки компонента

В оставшейся части этой главы мы подробно остановимся на функциональном тестировании с примерами. Тестирование качества сервиса выходит за рамки этой книги. После того, как программные компоненты были собраны вместе в качестве системы, система в целом проходит проверку, подобную системному тестированию. Объем тестирования системы и подход остаются теми же, независимо от того, является ли система компонентно-ориентированной или нет.

## Валидация интерфейсов компонента
На этом этапе тестировщик проверяет, что реализация компонента предоставляет интерфейсы, которые были указаны в спецификациях компонентов. Тестирование может происходить как методом белого ящика, так и методом черного ящика.

При использовании методики тестирования белого ящика, тестировщик проверяет код компонента на наличие реализации интерфейсов, соответствующей спецификации.

При использовании методики тестирования черного ящика, тестировщик развертывает компонент в интегрированной среде компонентов вместе с тестовым драйвером. Во время теста тестовый драйвер пытается использовать предоставленный интерфейс. Тест считается пройденным при успешной интеграции тестового драйвера и тестируемого компонента. Рассмотрим оба метода на примере.

### Пример валидации белого ящика
Рассмотрим компонент `TableBiz` из примера POS, с которым мы познакомились в главе 4. Рассмотрим метод тестирования, используя OSGi реализацию компонентной модели (смотри cекцию 5.8). Спецификация компонента `TableBiz` указывает, что он должен предоставлять интерфейс, указанный ниже:

```java
public interface ITableBiz {

	public abstract int getNoOfTables();

	public abstract List<Table> getOccupiedTables();

	public abstract List<Table> getEmptyTables();

	public abstract void occupyTable(Table table, int noOfGuests, String waiter)
			throws Exception;

	public abstract void unOccupyTable(Table table) throws Exception;

	public abstract void reconfigureTables(int newNoOfTables) throws Exception;

}
```

Давайте воспользуемся методикой тестирования белого ящика, чтобы проверить, что компонент `TableBiz` предоставляет интерфейс. С случае тестирования белого ящика, мы проверяем исходный код реализации `TableBiz` компонента. Мы видим из исходного кода, что компонент выполнен в виде OSGi модуля, и модуль содержит класс `TableBiz`. Класс `TableBiz` реализует java интерфейс `ITableBiz`. Дальше мы замечаем, что OSGi модуль включает описание декларативного сервиса, задающего класс `TableBiz` в качестве класс-компонента, который предоставляет интерфейс `ITableBiz`, как показано ниже:

```xml
<?xml version = "1.0" encoding = "UTF-8"?>
<scr:component xmlns:scr = "http://www.osgi.org/xmlns/scr/v1.1.0"
    name = "codabook.pos.table.biz">
<implementation class = "codabook.pos.table.biz.impl.TableBiz"/>
<service>
    <provide interface = "codabook.pos.table.biz.ifce.ITableBiz"/>
</service>
<reference bind = "bindEMF" cardinality = "1..1"
    interface = "javax.persistence.EntityManagerFactory"
    name = "EntityManagerFactory"
    policy = "static"/>
</scr:component>
```

Таким образом, проверив реализацию компонента методом белого ящика мы убедились, что он действительно предоставляет интерфейс ITableBiz согласно спецификации. В следующей секции мы продемонстрируем тестирование черного ящика для валидации интерфейса.

### Пример валидации черного ящика

Теперь рассмотрим методику тестирования черного ящика, с помощью которой мы можем установить, что компонент действительно обеспечивает интерфейс в соответствии со спецификацией. В тестировании черного ящика мы принимаем данный компонент как черный ящик, то есть мы не обладаем никаким знанием о его реализации и внутреннем устройстве. Мы развёртываем компонент в среде OSGi и проверяем предоставленный интерфейс. Чтобы протестировать что развернутый компонент предоставляет указанный интерфейс, мы используем тестовый драйвер, который будет потреблять данный интерфейс. Если тестовый драйвер успешно использовал предоставленный интерфейс, валидация считается успешной. Если же тестовый драйвер не смог успешно использовать интерфейс, то валидация терпит неудачу.

Для валидации компонента `TableBiz` нам нужен компонент тестового драйвера, который будет потреблять интерфейс `ITableBiz`. Мы создаем новый OSGi модуль `POS.Test.Table.Biz`, в котором есть есть декларативный сервис-компонент, связанный с сервисом ITableBiz. Код для компонента предоставлен ниже:

```java
public class TestTableBiz {

  private ITableBiz tableBiz;

  public void setTableBiz(ITableBiz tableBiz) {
    this.tableBiz = tableBiz;
  }

  public void activate() {
    if (tableBiz ! = null)
      System.out.println("SUCCESS - Got ITableBiz service");
    else
      System.out.println("FAIL - Could not get ITableBiz service");
  }
}
```
Реализация компонента зависит от `ITableBiz` через атрибут `tableBiz`. Внедрение зависимости поддерживается с помощью метода `setTableBiz()`. Метод `activate()` проверяет переданную компоненту ссылку. Описание декларативного сервиса компонента представлено ниже:

```xml
<?xml version = "1.0" encoding = "UTF-8"?>
<scr:component xmlns:scr = "http://www.osgi.org/xmlns/scr/v1.1.0"
    name = "codabook.test.table.biz">
<implementation class = "codabook.pos.test.tablebiz.TestTableBiz"/>
<reference bind = "setTableBiz" cardinality = "1..1"
    interface = "codabook.pos.table.biz.ifce.ITableBiz"
    name = "ITableBiz"
    policy = "static"/>
</scr:component>
```

Класс реализации `TestTableBiz` зависит от интерфейса `ITableBiz`, и внедрение зависимости осуществляется через связывающий метод `setTableBiz()`. При развертывании этого тестового драйвера вместе с компонентом TableBiz и модулем POS.Data, видно что метод `activate()` компонента тестового драйвера выводит сообщение об успешной интеграции. Таким образом мы проверили что компонент `TableBiz` действительно предоставляет интерфейс `ITableBiz` согласно проектной спецификации.

Методика тестирования черного ящика, показанная выше, выгодна при приобретении сторонних компонентов, чей исходный код недоступен. Верификация интерфейса также раскрывает любые несовместимости, которые могут существовать тем что требуется и тем что имеется.

### Верификация реализации компонента — тестирование белого ящика

Во время тестирования реализации компонента, важно убедиться, что функциональность правильно реализована. В традиционном тестировании ПО, такого рода проверка осуществляется через тестирование белого ящика. Аналогичное тестирование проводится в случае проверки внутренней реализации компонента. Это тестирование проводится с полным знанием внутренних деталей реализации компонента. Зная логику реализации каждого внутреннего сегмента компонента, тестовые случаи разрабатываются, чтобы убедиться, что реализация не содержит ошибок. Эффективность тестовых случаев измеряется объемом покрытия операторов, объектов, взаимодействий, ветвей и так далее.

В качестве примера, рассмотрим компонент `TableBiz` который был проверен в последнем разделе. Как уже говорилось, этот компонент предоставляет интерфейс `ITableBiz`. При проверке внутренней реализации, нужно протеститровать все операции, определенные в интерфейсе `ITableBiz`. Для наглядности, приведем методику тестирования для одной из операций, определенных в интерфейсе `ITableBiz`: `occupyTable()`. Эта операция реализована в классе `TableBiz`. Фрагмент кода реализации приведен ниже:

```java
public void occupyTable(Table table, int noOfGuests, String waiter) throws Exception {
	
	if (table == null) {
		throw new Exception("Cannot checkin - Invalid Table");
	}
	
	if (table.isOccupied()) {
		throw new Exception("Table is already occupied");
	}
	

	if (noOfGuests == 0) {
		throw new Exception("Cannot checkin - Invalid number of guests");
	}

	if (waiter == null) {
		throw new Exception("Cannot checkin - Invalid waiter name");
	}

	Order order = new Order();
	
	table.occupy(noOfGuests, waiter, order);
}
```

Исследуя эту реализацию, мы видим, что у нас есть четыре условных оператора. Тестирование методом белого ящика использует тестирование граничных значений для проверки условий. При тестирование граничных значений на вход функции подается диапазон входных значений, и поведение вызванной функции проверяется в соответствии со спецификацией для всех значений. Граничные значения подбираются таким образом чтобы быть на грани успешного или не успешного выполнения покрытых условных операций. Такие значения называются граничными. Основываясь на этой методике мы получаем тестовые данные, сформулированные в таблице 10.1, чтобы протестировать вышеупомянутую реализацию.

Например, чтобы протестировать первый  условный блок кода, есть тестовые случаи 1 и 2 в таблице 10.1. Тестовый случай 1 проверяет что реализация принимает и обрабатывает объект не равный `null`, который описывает свободный столик. Тестовый случай 2 проверяет что реализация правильно обрабатывает `null` значение для столика. Остальные тестовые случаи проводят такую проверку для оставшихся условных блоков реализации. 


| Номер | Столик| Кол-во гостей | Имя официанта | Ожидаемое поведение |
| -- | -- | -- | -- | -- |
| 1 | `occupied = false` | 4 | `TestWaiter` | Success |
| 2 | `null` | 4 | `TestWaiter` | Failure; invalid table |
| 3 | `occupied = true` | 4 | `TestWaiter` | Failure; table is occupied |
| 4 | `occupied = false` | 0 | `TestWaiter` | Failure; invalid no. of guests |
| 5 | `occupied = false` | -1 | `TestWaiter` | Failure; invalid no. of guests |
| 6 | `occupied = false` | 2 | `null` | Failure; invalid waiter |

*таблица 10.1*

Чтобы провести эти тесты нам нужно развернуть компонент `TableBiz` и вызвать метод `occupyTable()`. Мы дорабатываем компонент тестового драйвера, введенного в предыдущей секции, таким образом, что мы можем вызвать метод `occupyTable()` с выше заданным набором значений. Метод `activate()` класса `TestTableBiz`, представленного в последнем разделе, доработан и показан ниже:

```java
public void activate() {
    if (tableBiz ! = null) {
        System.out.println("SUCCESS - Got ITableBiz service");
        testCase1();
        testCase2();
        testCase3();
        testCase4();
        testCase5();
        testCase6();
    }
    else
        System.out.println("FAIL - Could not get ITableBiz service");
}
```

Как можно увидеть из кода, метод `activate()` вызывает методы, которые вызывают отдельные тестовые случаи, передавая подходящие тестовые данные. Рассмотрим, для примера, метод `testCase1()`, который тестирует первый тестовый случай из таблицы 10.1. Код метода представлен ниже:

```java
private void testCase1() {
  
  System.out.println("\n— — — — — — — — — — -");
  System.out.println("Executing Test Case 1");
  
  Table table = new Table (1);
  table.setOccupied(false);
  
  System.out.println("Created an empty table");
  printTableStatus(table);
  
  String waiter = "TestWaiter";
  int noOfGuests = 4;
  
  System.out.println("Calling occupy table with TestWaiter and 4 guests");
  
  try {  
    tableBiz.occupyTable(table, noOfGuests, waiter);  
  } catch (Exception e) {  
    System.out.println("ERROR - " + e.getMessage());  
  } finally {
    printTableStatus(table);
    System.out.println("— — — — — — — — — — -\n");
  }
}
```

Метод `TestCase1()` создает подходящие тестовые данные в соответствии с таблицей 10.1. После того как данные готовы он вызывает тестируемый метод `occupyTable()`. Аналогично этому, другие методы вызывают тестовые случаи приведенные в таблице 10.1. Развернув компонент `TestTableBiz` вместе с компонентом `TableBiz` и `POSData` OSGi модулем, затем выполнив получившийся сборку, мы сможем наблюдать результаты тестовых случаев, приведенные в таблице 10.2 

| Номер | Столик| Кол-во гостей | Имя официанта | Ожидаемое поведение | Результат |
| -- | -- | -- | -- | -- |
| 1 | `occupied = false` | 4 | `TestWaiter` | Success | Pass |
| 2 | `null` | 4 | `TestWaiter` | Failure; invalid table |Pass |
| 3 | `occupied = true` | 4 | `TestWaiter` | Failure; table is occupied |Pass |
| 4 | `occupied = false` | 0 | `TestWaiter` | Failure; invalid no. of guests |Pass |
| 5 | `occupied = false` | -1 | `TestWaiter` | Failure; invalid no. of guests |Fail |
| 6 | `occupied = false` | 2 | `null` | Failure; invalid waiter |Pass |

*таблица 10.2*

Мы видим что все тестовые случаи кроме тестового случая 5 выполнились успешно. В этом тестовом случае ожидалось, что реализация отвергнет количество гостей, меньшее нуля. Однако реализация приняла это значение. Взглянув на код метода `occupyTable()` в компоненте `TableBiz`, мы видим что это поведение обусловлено следующим кодом:

```java
if (noOfGuests == 0) {
	throw new Exception("Cannot checkin - Invalid number of guests");
}
```

Чтобы исправить эту ошибку и заставить тестовый случай 5 выполняться успешно, необходима следующая поправка:

```java
if (noOfGuests <= 0) {
	throw new Exception("Cannot checkin - Invalid number of guests");
}
```

При использовании исправленного кода тестовый случай 5 проходится успешно.

## Верификация функциональности компонента - тестирование черного ящика

Набор тестов, проведенных в последнем разделе, сфокусирован на тестировании реализации компонента с полным знанием о спецификации реализации и действительной реализации. Такой тип тестирования возможен когда компонент тестируется его же разработчиком. Однако, компонент потребляется в контексте системы, и пользователи компонента знают лишь об интерфейсе компонента и его функциональной спецификации. У них нет доступа к реализации компонента или к спецификации реализации. Важно, что компонент тестируется до того как развертывается и собирается в контексте системы. Для таких целей тестирование черного ящика на уровне компонентов необходимо, чтобы убедиться, что компонент выполняет функции в соответствии с их функциональной спецификацией.

Тестовые случаи черного ящика опираются на функциональную спецификацию интерфейса, предоставленного компонентом. На основании функциональных спецификаций, тестовые случаи разрабатываются для покрытия всех методов в интерфейсе. Множество тестовых случаев может понадобиться для одного метода, чтобы исчерпывающе протестировать его поведение на всем спектре входных значений. Ниже мы рассмотрим тестовые случаи и метод тестирования компонента `TableBiz`. Интерфейс, предоставленный компонентом `TableBiz`, приведен ниже для справки:

```java
public interface ITableBiz {

	public abstract int getNoOfTables();

	public abstract List<Table> getOccupiedTables();

	public abstract List<Table> getEmptyTables();

	public abstract void occupyTable(Table table, int noOfGuests, String waiter)
			throws Exception;

	public abstract void unOccupyTable(Table table) throws Exception;

	public abstract void reconfigureTables(int newNoOfTables) throws Exception;
}
```

Функциональные спецификации методов приведены в таблице 10.3

| Номер | Метод| Функциональная спецификация | 
| -- | -- | -- |
| 1 | `getNoOfTables()` | Возвращает количество столиков отслеживаемое компонентом `TableBiz` |
| 2 | `getOccupiedTables()` | Возвращает список занятых столиков. Если ни один столик не занят, то размер списка равен нулю |
| 3 | `getEmptyTables()` | Возвращает список незанятых столиков. Если все столики заняты, то размер списка равен нулю
| 4 | `occupyTable(table, noOfGuests, waiter)` | Отмечает столик как занятый если: столик не занят, `NoOfGuests` больше нуля, официант не равен `null`|
| 5 | `unOccupyTable(table)` | Отмечает столик как незанятый если: столик занят, заказ на столик равен `null` или не имеет элементов заказа. Если любое из условий не выполнено, то вбрасывается исключение с сообщением ошибки |
| 6 | `reconfigureTables()` |  Изменяет количество отслеживаемых компонентом `TableBiz` столиков |

*таблица 10.3*

На основании функциональных спецификаций, тестовые случаи разработаны для проверки всех методов интерфейса. В следующих разделах мы рассмотрим несколько тестовых случаев и процедур их выполнения. Эти тестовые случаи являются лишь набором для примера и не достаточны, чтобы охватить все сценарии, которые должны быть протестированы.

### Тестовый случай для количества столиков

В этом тестовом случае мы хотим проверить методы, через которые задается количество столиков в компоненте `TableBiz`. Для этого есть 2 метода и мы тестируем оба с помощью следующих действий:
1. Вызвать `reconfigureTables()` с 20-ю столиками
2. Вызвать `getNoOfTables()`

В конце этой последовательности мы ожидаем получить число 20 в качестве возвращаемого значения метода `getNoOfTables()`. Чтобы провести этот тест мы используем компонент тестового драйвера, аналогичный используваемым в последних двух разделах. Метод `activate()` тестового драйвера вызывает методы реализации тестового случая. Код реализации данного тестового случая представлен ниже:

```java
private void testCase1() {
    
  System.out.println("\n— — — — — — — — — — -");
  System.out.println("Executing Test Case 1");
  
  try {
    System.out.println("Calling reconfigureTables(20)");
    tableBiz.reconfigureTables(20);
    System.out.println("Calling getNoOfTables() and it returned " + tableBiz.getNoOfTables());
  } catch (Exception e) {
    System.out.println("ERROR - " + e.getMessage());
  } finally {  
    System.out.println("— — — — — — — — — — -\n");
  }
}
```

Как видно из кода, тестовый драйвер сначала вызывает метод компонента `reconfigureTables()`. Это сопровождается вызовом `getNoOfTables()`. Если собрать и запустить компоненты тестового драйвера и `TableBiz`, то мы можем убедиться что возвращаемое значение соответствует ожидаемому числу 20.

### Тестовый случай для функциональности заказа столика.

В этом тестовом случае мы хотим проверить операции по заказу столиков. Мы тестируем это с помощью следующих действий:

1. Вызвать `occupyTable()` для 5ого столика
2. Вызвать `occupyTable()` для 10ого столика
3. Вызвать `getOccupiedTables()`

После выполнения тестового случая мы ожидаем, что `getOccupiedTables()` вернет список из 2ух столиков: столик 5 и столик 10. Чтобы выполнить этот тестовый случай, мы пишем еще один метод в компоненте тестового драйвера, код для которого представлен ниже:

```java
private void testCase2() {
  System.out.println("Executing Test Case 2");
  try {    
    List<Table> tables = tableBiz.getEmptyTables();  
    Table table5 = null;    
    Table table10 = null;  
    for (Table table : tables) {    
      if (table.getTableNo() = = 5)    
      table5 = table;  
      if (table.getTableNo() = = 10)    
      table10 = table;
    }
    System.out.println("Calling occupy table for table 5");
    tableBiz.occupyTable(table5, 4, "waiter");
    System.out.println("Calling occupy table for table 10");
    tableBiz.occupyTable(table10, 4, "waiter");
    System.out.println("Calling getOccupiedTables() and it returned following tables ");    
    tables = tableBiz.getOccupiedTables();
    for (Table table : tables) {
      System.out.println("Table " + table.getTableNo());
    }        
  } catch (Exception e) {
    System.out.println("ERROR - " + e.getMessage());    
  } finally {    
    System.out.println("— — — — — — — — — — -\n");
  }
}
```

Выполнив этот тестовый случай, мы находим, что вывод соответсвует ожидаемомому: столик 5 и столик 10.

### Тестовый случай для функциональности освобождения столика

В этом тестовом случае мы хотим проверить операции для освобождения столиков. Мы тестируем методы с помощью следующих действий:
1. Вызвать `unOccupyTable()` для столика 5
2. Вызвать `getOccupiedTables()`

После выполнения тестового случая мы ожидаем, что `getOccupiedTables()` вернет столик 10. Чтобы выполнить этот тестовый случай, мы пишем еще один метод в компоненте тестового драйвера, код для которого представлен ниже:

```java
private void testCase3() {
  System.out.println("Executing Test Case 4");
  try {
    List<Table> tables = tableBiz.
    getOccupiedTables();
    Table table5 = null;
    for (Table table : tables) {
      if (table.getTableNo() = = 5)
        table5 = table;
      break;
    }
    
    System.out.println("Calling unOccupy table for table 5");
    tableBiz.unOccupyTable(table5);
    System.out.println("Calling getOccupiedTables() and it returned following tables ");
    tables = tableBiz.getOccupiedTables();  
    for (Table table : tables) {
      System.out.println("Table " + table.getTableNo());
    }        
  } catch (Exception e) {
    System.out.println("ERROR - " + e.getMessage());  
  } finally {    
    System.out.println("— — — — — — — — — — -\n");
  }
}
```

Выполнив этот тестовый случай, мы видим, что вывод соответствует ожидаемому: столик 10.

Как упоминалось ранее, три тестовых случая, представленные выше, являются лишь примером набора тестов. Полное тестирование черного ящика требует гораздо большего количества тестов, которые охватывают целый ряд сценариев.


## Выводы

В этой главе мы ввели понятия тестирования ПО и тестирования программных компонентов. Мы узнали, что тестирование компонентов включает валидацию предоставленных компонентом интерфейсов, верификацию внутренней реализации компонента через тестирование белого ящика, и функциональную верификацию компонента через тестирование черного ящика. Мы представили примеры, чтобы объяснить как проводить эти тесты.

## Контрольные вопросы

1. В чем разница между тестированием черного ящика и тестирование белого ящика?
2. Каковы различия между модульным тестированием, тестированием интеграции, и системным тестированием?
3. Почему функциональное тестирование отличается от качества тестирования сервиса?
4. Как можно проверить что реализация компонента соответствует его спецификации интерфейса?
5. Что включает в себя проверка внутренней реализации программных компонентов?
6. Может ли тестирование белого ящика проводиться пользователем компонента? Почему?
7. Каким образом пользователь компонента может убедиться, что он или она получила правильный компонент?
8. Что такое тестовые компоненты и как они относятся к тестированию черного ящика и тестированию белого ящика?
