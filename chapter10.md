# Тестирование компонентно-ориентированного ПО
## Введение
В предыдущих главах мы узнали о принципах КОРС, различных компонентных моделях, доступных в Java, а и о том как разрабатывать и проектировать компонентно-ориентированную систему. В этой главе мы рассмотрим тестирование системных компонентов. Тестирование играет большую роль в обеспечении качества ПО. Как мы увидим дальше, тестирование системных компонентов немного отличается традиционного тестирования.
## Понятия в тестировании ПО
Как и во всех других сферах жизни, человеку свойственно ошибаться и в разработке программного обеспечения. Без надлежащего тестирования нельзя считать, что программное обеспечение является правильным, полным, и хорошего качества. После того как команда программистов закончит разработку, независимая группа тестировщиков проводит контроль качества разработанного ПО. Тестирование выявляет ошибки в реализации логики, особенности, пропущенные при реализации, и другие качественные недостатки. Все это записывается как дефекты программы. После первого раунда тестирования обнаруженные дефекты устраняются и продукт подвергается следующему раунду тестирования. Контроль качества ПО может включать в себя несколько раундов тестирования, устранения ошибок и повторного тестирования, пока ошибки не будут уменьшены до приемлемого уровня.

Различные типы тестов проводятся на различных этапах традиционного жизненного цикла разработки ПО. Некоторые виды тестов проверяют соответствующие артефакты процесса разработки, а не самого продукта. Мы сосредоточимся на методах тестирования, охватывающих программу, а не артефакты.

По ходу процесса разработки, когда небольшие модули ПО становятся законченными, разработчики проводят модульное тестирование готовых модулей.

Модульное тестирование подразумевает проверку разработанного ПО на основе знаний о внутренней спецификации реализации и фактической реализации программного обеспечения. Такое тестирование называется тестированием методом белого ящика.

Когда отдельные разработчики завершают программирование поставленных задач, участки программы собираются воедино и интегрируются. Проводятся тесты чтобы убедиться, что блоки ПО работают и взаимодействуют согласно спецификации. Тестирование на этом этапе известно как интеграционное тестирование. Как правило, интеграционное тестирование использует принцип белого ящика.

Когда программное обеспечение для всей системы готово, система проверяется на соответствие техническим требованиям. Этот этап тестирования известен как системное тестирование. В отличие от двух других фаз тестов, в которых применялось тестирование белого ящика, системное тестирование относится ко всей системе как к черному ящику, без каких-либо предположений о реализации. Смысл тестов черного ящика в том, чтобы убедиться что функциональность всей системы соответствует указанной в спецификации. Тестовые случаи разрабатываются только с оглядкой на спецификацию, без знаний о требований к реализации или знаний о самой реализации. Такое тестирование называется тестированием черного ящика.
## Понятия в тестировании компонентно-ориентированного ПО
Цикл разработки компонентно-ориентированного ПО отличается от традиционного жизненного цикла разработки как уже описано в главе 1.8. В этой главе объясняется, что компоненты берутся либо уже в готовом виде, либо разрабатываются до сборки в систему. В любом случае, до сборки компоненты нужно протестировать. Тестирование компонентов можно в общем разделить на функциональное тестирование и тестирование качества сервиса.

Функциональное тестирование включает:
1. Проверку интерфейсов компонентов
2. Проверку реализации компонентов - тестирование белого ящика
3. Тестирование функциональности компонентов - тестирование белого ящика

Тестирование качества сервиса включает:
1. Проверку производительности компонентов
2. Проверку обработки ошибок компонента
3. Проверку точности данных компонента
4. Проверку функциональности компонента на восстановление после ошибок
5. Проверку возможности повторного использования компонента
6. Проверку надежности компонента
7. Оценку возможной степени поддержки компонента

В оставшейся части этой главы мы подробно остановимся на функциональном тестировании с примерами. Тестирование качества сервиса выходит за рамки этой книги. После того, как программные компоненты были собраны вместе в качестве системы, система в целом проходит проверку, подобную системному тестированию. Объем тестирование системы и подход остаются теми же, независимо от того, является ли система компонентно-ориентированной или нет.

## Валидация интерфейсов компонента
На этом этапе тестировщик проверяет, что реализация компонента обеспечивает интерфейсы, которые были указаны в спецификациях компонентов. Тестирование может происходить как методом белого ящика, так и методом черного ящика.

При использовании методики тестирования белого ящика, тестировщик проверяет код компонента на наличие реализации интерфейсов, соответствующей спецификации.

При использовании методики тестирования черного ящика, тестировщик развертывает компонент в интегрированной среде компонентов вместе с тестовым драйвером. Во время теста тестовый драйвер пытается использовать предоставленный интерфейс. Тест считается пройденным при успешной интеграции тестового драйвера и тестируемого компонента. Рассмотрим оба метода на примере.

### Пример валидации белого ящика
Рассмотрим компонент TableBiz из примера POS, с которым мы познакомились в главе 4. Чтобы рассмотрим метод тестирования, используя OSGi реализацию компонентной модели (смотри cекцию 5.8). Спецификация компонента TableBiz указывает, что он должен предоставлять интерфейс, показанный ниже:
```java
public interface ITableBiz {

	public abstract int getNoOfTables();

	public abstract List<Table> getOccupiedTables();

	public abstract List<Table> getEmptyTables();

	public abstract void occupyTable(Table table, int noOfGuests, String waiter)
			throws Exception;

	public abstract void unOccupyTable(Table table) throws Exception;

	public abstract void canPayBill(Table table) throws Exception;

	public abstract void reconfigureTables(int newNoOfTables) throws Exception;

	public abstract void canTableTakeOrders(Table table) throws Exception;

}
```

Давайте воспользуемся методикой тестирования белого ящика, чтобы проверить, что компонент TableBiz предоставляет интерфейс. С случае тестирования белого ящика, мы проверяем исходный код реализации TableBiz компонента. Мы видим из исходного кода, что компонент выполнен в виде OSGi модуля, и модуль содержит класс TableBiz. Класс TableBiz реализует java интерфейс ITableBiz. Дальше мы замечаем, что OSGi модуль включает описание декларативного сервиса, задающего класс TableBiz в качестве класс-компонента, который предоставляет интерфейс ITableBiz, как показано ниже:
```xml
<?xml version = "1.0" encoding = "UTF-8"?>
<scr:component xmlns:scr = "http://www.osgi.org/xmlns/scr/v1.1.0"
    name = "codabook.pos.table.biz">
<implementation class = "codabook.pos.table.biz.impl.TableBiz"/>
<service>
    <provide interface = "codabook.pos.table.biz.ifce.ITableBiz"/>
</service>
<reference bind = "bindEMF" cardinality = "1..1"
    interface = "javax.persistence.EntityManagerFactory"
    name = "EntityManagerFactory"
    policy = "static"/>
</scr:component>
```

Таким образом, проверив реализацию компонента методом белого ящика мы убедились, что он действительно предоставляет интерфейс ITableBiz согласно спецификации. В следующей секции мы продемонстрируем тестирование черного ящика для валидации интерфейса.

### Пример валидации черного ящика

Теперь рассмотрим методику тестирования черного ящика, с помощью которой мы можем установить, что компонент действительно обеспечивает интерфейс в соответствии со спецификацией. В тестировании черного ящика мы принимаем данный компонент как черный ящик, то есть мы не обладаем никаким знанием о его реализации и внутреннем устройстве. Мы развёртываем компонент в среде OSGi и проверяем предоставленный интерфейс. Чтобы протестировать что развернутый компонент предоставляет указанный интерфейс, мы используем тестовый драйвер, который будет потреблять данный интерфейс. Если тестовый драйвер успешно использовал предоставленный интерфейс, валидация считается успешной. Если же тестовый драйвер не смог успешно использовать интерфейс, то валидация терпит неудачу.

Для валидации компонента TableBiz нам нужен компонент тестового драйвера, который будет потреблять интерфейс ITableBiz. Мы создаем новый OSGi модуль POS.Test.Table.Biz, в котором есть есть декларативный сервис-компонент, связанный с сервисом ITableBiz. Код для компонента предоставлен ниже:
```java
public class TestTableBiz {

  private ITableBiz tableBiz;

  public void setTableBiz(ITableBiz tableBiz) {
    this.tableBiz = tableBiz;
  }

  public void activate() {
    if (tableBiz ! = null)
      System.out.println("SUCCESS - Got ITableBiz service");
    else
      System.out.println("FAIL - Could not get ITableBiz service");
  }
}
```
Реализация компонента зависит от ITableBiz через атрибут tableBiz. Внедрение зависимости поддерживается с помощью метода setTableBiz(). Метод activate() проверяет переданную компоненту ссылку. Описание декларативного сервиса компонента представлено ниже:

```xml
<?xml version = "1.0" encoding = "UTF-8"?>
<scr:component xmlns:scr = "http://www.osgi.org/xmlns/scr/v1.1.0"
    name = "codabook.test.table.biz">
<implementation class = "codabook.pos.test.tablebiz.TestTableBiz"/>
<reference bind = "setTableBiz" cardinality = "1..1"
    interface = "codabook.pos.table.biz.ifce.ITableBiz"
    name = "ITableBiz"
    policy = "static"/>
</scr:component>
```

Обратите внимание на выделенную жирным часть описания. Класс реализации TestTableBiz зависит от интерфейса ITableBiz, и внедрение зависимости осуществляется через связывающий метод setTableBiz(). При развертывании этого тестового драйвера вместе с компонентом TableBiz и модулем POS.Data, видно что метод activate() компонента тестового драйвера выводит сообщение об успешной интеграции. Таким образом мы проверили что компонент TableBiz действительно предоставляет интерфейс ITableBiz согласно проектной спецификации.

Методика тестирования черного ящика, показанная выше, выгодна при приобретении сторонних компонентов, чей исходный код недоступен. Верификация интерфейса также раскрывает любые несовместимости, которые могут существовать тем что требуется и тем что имеется.

### Верификация реализации компонента — тестирование белого ящика
Во время тестирования реализации компонента, важно убедиться, что функциональность правильно реализована. В традиционном тестировании ПО, такого рода проверка осуществляется через тестирование белого ящика. Аналогичное тестирование проводится в случае проверки внутренней реализации компонента. Это тестирование проводится с полным знанием внутренних деталей реализации компонента. Зная логику реализации каждого внутреннего сегмента компонента, тестовые случаи разрабатываются, чтобы убедиться, что реализация не содержит ошибок. Эффективность тестовых случаев измеряется объемом покрытия операторов, объектов, взаимодействий, ветвей и так далее.

В качестве примера, рассмотрим компонент TableBiz который был проверен в последнем разделе. Как уже говорилось, этот компонент предоставляет интерфейс ITableBiz. При проверке внутренней реализации, нужно протеститровать все операции
определенные в интерфейсе ITableBiz. Для наглядности, приведем методику тестирования для одной из операций, определенных в интерфейсе ITableBiz: occupyTable(). Эта операция реализована в классе TableBiz. Фрагмент кода реализации приведен ниже:

```java
public void occupyTable(Table table, int noOfGuests, String waiter) throws Exception {
	
	if (table == null) {
		throw new Exception("Cannot checkin - Invalid Table");
	}
	
	if (table.isOccupied()) {
		throw new Exception("Table is already occupied");
	}
	

	if (noOfGuests == 0) {
		throw new Exception("Cannot checkin - Invalid number of guests");
	}

	if (waiter == null) {
		throw new Exception("Cannot checkin - Invalid waiter name");
	}

	Order order = new Order();
	
	table.occupy(noOfGuests, waiter, order);
}
```

Исследуя эту реализацию, мы видим, что у нас есть четыре условных оператора. Тестирование методом белого ящика использует тестирование граничных значений для проверки условий. При тестирование граничных значений на вход функции подается диапазон входных значений, и поведение вызванной функции проверяется в соответствии со спецификацией для всех значений. Граничные значения подбираются таким образом чтобы быть на грани успешного или не успешного выполнения покрытых условных операций. Такие значения называются граничными. Основываясь на этой методике мы получаем тестовые данные сформулированные в таблице 10.1 чтобы протестировать вышеупомянутую реализацию.

Например, чтобы протестировать первый  условный блок кода (выделен жирным выше), есть тестовые случаи 1 и 2 в таблице 10.1. Тестовый случай 1 проверяет что реализация принимает и обрабатывает объект не равный null, который описывает свободный столик. Тестовый случай 2 проверяет что реализация правильно обрабатывает null значение для столика. Остальные тестовые случаи проводят такую проверку для оставшихся условных блоков реализации. 
 
Чтобы провести эти тесты нам нужно развернуть компонент TableBiz и вызвать метод occupyTable(). Мы дорабатываем компонент тестового драйвера, введенного в предыдущей секции, таким образом, что мы можем вызвать метод occupyTable() с выше заданным набором значений. Метод activate() класса TestTableBiz, представленного в последнем разделе, доработан и показан ниже:

```java
public void activate() {
    if (tableBiz ! = null) {
        System.out.println("SUCCESS - Got ITableBiz service");
        testCase1();
        testCase2();
        testCase3();
        testCase4();
        testCase5();
        testCase6();
    }
    else
        System.out.println("FAIL - Could not get ITableBiz service");
}
```

Как можно увидеть из кода, метод activate() вызывает методы, которые вызывают отдельные тестовые случаи, передавая подходящие тестовые данные. Рассмотрим, для примера, метод testCase1(), который тестирует первый тестовый случай из таблицы 10.1. Код метода представлен ниже:

```java
private void testCase1() {
  
  System.out.println("\n— — — — — — — — — — -");
  System.out.println("Executing Test Case 1");
  
  Table table = new Table (1);
  table.setOccupied(false);
  
  System.out.println("Created an empty table");
  printTableStatus(table);
  
  String waiter = "TestWaiter";
  int noOfGuests = 4;
  
  System.out.println("Calling occupy table with TestWaiter and 4 guests");
  
  try {  
    tableBiz.occupyTable(table, noOfGuests, waiter);  
  } catch (Exception e) {  
    System.out.println("ERROR - " + e.getMessage());  
  } finally {
    printTableStatus(table);
    System.out.println("— — — — — — — — — — -\n");
  }
}
```

Метод TestCase1() Создает подходящие тестовые данные в соответствии с таблицей 10.1. После того как данные готовы он вызывает тестируемый метод occupyTable(). Аналогично этому, другие методы вызывают тестовые случаи приведенные в таблице 10.1. Развернув компонент TestTableBiz вместе с компонентом TableBiz и POSData OSGi модулем, затем выполнив получившийся сборку, мы сможем наблюдать результаты тестовых случаев, приведенные в таблице 10.2 

Мы видим что все тестовые случаи кроме тестового случая 5 вернули ошибку. В этом в этом тестовом случае ожидалось, что реализация отвергнет количество гостей, меньшее нуля. Однако реализация приняла это значение. Взглянув на код метода occupyTable() в компоненте TableBiz, мы видим что это поведение обусловлено следующим кодом:
```java
if (noOfGuests == 0) {
	throw new Exception("Cannot checkin - Invalid number of guests");
}
```

Чтобы исправить эту ошибку и заставить тестовый случай 5 выполняться успешно, необходима следующая поправка:

```java
if (noOfGuests <= 0) {
	throw new Exception("Cannot checkin - Invalid number of guests");
}
```

При использовании исправленного кода тестовый случай 5 проходится успешно.
